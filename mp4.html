<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>åœ–åƒé®ç½© Pro - MP4 åŸç”Ÿè¼¸å‡ºç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/coi-serviceworker/0.1.7/coi-serviceworker.min.js"></script>
    <style>
        body { font-family: 'PingFang TC', 'Microsoft JhengHei', sans-serif; display: flex; flex-direction: column; align-items: center; background: #1a1a1a; color: #eee; padding: 20px; }
        .controls { background: #2c2c2c; padding: 20px; border-radius: 15px; display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; width: 100%; max-width: 800px; border: 1px solid #444; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .full-width { grid-column: span 2; }
        .section-title { font-weight: bold; color: #9b59b6; margin-top: 10px; border-bottom: 1px solid #444; padding-bottom: 5px; }
        .mode-selector { background: #3d3d3d; padding: 15px; border-radius: 8px; display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
        
        canvas, video { 
            max-width: 95vw; border: 2px solid #555; margin-top: 10px; border-radius: 8px;
            background-image: linear-gradient(45deg, #222 25%, transparent 25%), linear-gradient(-45deg, #222 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #222 75%), linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
        }

        input[type="range"] { width: 100%; cursor: pointer; }
        input[type="text"] { width: 100%; padding: 10px; box-sizing: border-box; background: #444; border: 1px solid #666; color: white; border-radius: 6px; }
        label { font-size: 13px; color: #ccc; display: block; margin-bottom: 5px; }
        
        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
        button { flex: 1; padding: 12px; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; transition: 0.3s; min-width: 140px; }
        
        .btn-random { background: #34495e; color: white; }
        .btn-mp4 { background: #9b59b6; color: white; }
        .btn-save-video { background: #3498db; color: white; display: none; }
        
        #status { text-align: center; color: #f1c40f; font-weight: bold; min-height: 24px; padding: 10px; border-radius: 5px; background: rgba(0,0,0,0.3); width: 100%; box-sizing: border-box; }
        .highlight { color: #f1c40f; font-weight: bold; }
    </style>
</head>
<body>

    <h2>ğŸ¨ åœ–åƒé®ç½© Pro (MP4 è¼¸å‡ºç‰ˆ)</h2>

    <div class="controls">
        <div class="full-width">
            <label>1. ä¸Šå‚³åœ–ç‰‡åº•åœ–ï¼š</label>
            <input type="file" id="upload" accept="image/*">
        </div>
        
        <div class="mode-selector full-width">
            <label style="width:100%"><span class="highlight">åœ–ç‰‡å‘ˆç¾ä½ç½®ï¼š</span></label>
            <input type="radio" name="displayPos" id="posBoard" value="board" checked><label for="posBoard">åœ–ç‰‡åœ¨æ¿é¢</label>
            <input type="radio" name="displayPos" id="posHole" value="hole"><label for="posHole">åœ–ç‰‡åœ¨å­”æ´</label>
        </div>

        <div class="mode-selector full-width">
            <label style="width:100%">ç¬¦è™Ÿé¡è‰²æ¨¡å¼ï¼š</label>
            <input type="radio" name="mode" id="modeHole" value="hole" checked><label for="modeHole">é€æ˜æŒ–å­”</label>
            <input type="radio" name="mode" id="modeRandom" value="random"><label for="modeRandom">éš¨æ©Ÿé¡è‰²</label>
            <input type="radio" name="mode" id="modeFixed" value="fixed"><label for="modeFixed">æŒ‡å®šé¡è‰²</label>
            <input type="color" id="fixedColorPicker" value="#ffffff">
        </div>

        <div>
            <label>ç¬¦è™Ÿå¤§å°: <span id="val-radius">25</span></label>
            <input type="range" id="radius" min="10" max="100" value="25">
        </div>
        <div>
            <label>åˆ†å¸ƒå¯†åº¦: <span id="val-spacing">40</span></label>
            <input type="range" id="spacing" min="15" max="150" value="40">
        </div>

        <div class="full-width section-title">æ–‡å­—èˆ‡ MP4 éŒ„è£½è¨­å®š</div>
        
        <div class="full-width">
            <label>è¼¸å…¥å¹²æ“¾æ–‡å­—ï¼š</label>
            <input type="text" id="overlayText" placeholder="è¼¸å…¥æ–‡å­—...">
        </div>
        <div>
            <label>æ°´å¹³ä½ç½® (X): <span id="val-posX">50</span>%</label>
            <input type="range" id="posX" min="0" max="100" value="50">
        </div>
        <div>
            <label>å‚ç›´ä½ç½® (Y): <span id="val-posY">50</span>%</label>
            <input type="range" id="posY" min="0" max="100" value="50">
        </div>
        <div>
            <label>éŒ„è£½ç§’æ•¸: <span id="val-duration">3</span> ç§’</label>
            <input type="range" id="duration" min="1" max="30" value="3">
        </div>
        
        <div id="status" class="full-width">è«‹å…ˆä¸Šå‚³åœ–ç‰‡</div>

        <div class="full-width btn-group">
            <button id="re-random" class="btn-random">é‡ç¹ªé è¦½</button>
            <button id="record-mp4" class="btn-mp4">ğŸš€ ç”¢ç”Ÿ MP4 å½±ç‰‡</button>
            <button id="save-video" class="btn-save-video">ğŸ’¾ ä¸‹è¼‰ MP4 æª”æ¡ˆ</button>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="preview-area" id="videoContainer" style="display:none; text-align:center;">
        <h3 style="color:#9b59b6">ğŸï¸ MP4 å½±ç‰‡é è¦½</h3>
        <video id="videoPreview" controls loop muted></video>
    </div>

    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
    <script>
        const { createFFmpeg, fetchFile } = FFmpeg;
        const ffmpeg = createFFmpeg({ log: false });

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const upload = document.getElementById('upload');
        const videoPreview = document.getElementById('videoPreview');
        const videoContainer = document.getElementById('videoContainer');
        const saveVideoBtn = document.getElementById('save-video');
        const status = document.getElementById('status');
        
        const controls = ['radius', 'spacing', 'posX', 'posY', 'duration', 'fixedColorPicker', 'overlayText'];
        const shapes = ['â– ','â—','âœ–','â›°ï¸','â¬†ï¸','â¬‡ï¸','â¬…ï¸','â¡ï¸','â—€ï¸','â–¶ï¸','âœš','âœ¦','â™¥','â™£','â™¦','â™ ','â‹','âˆ','âš¡ï¸'];
        let img = new Image();
        let isRecording = false;
        let mp4Url = null;

        upload.addEventListener('change', (e) => {
            const reader = new FileReader();
            reader.onload = (f) => {
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    status.textContent = "åœ–ç‰‡å·²è¼‰å…¥ï¼Œå¯é–‹å§‹ç”¢ç”Ÿ MP4";
                    draw();
                };
                img.src = f.target.result;
            };
            reader.readAsDataURL(e.target.files[0]);
        });

        controls.forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                const span = document.getElementById(`val-${id}`);
                if (span) span.textContent = document.getElementById(id).value;
                if (img.src && !isRecording) draw();
            });
        });

        function drawSymbols(sRadius, sSpacing, mode, isMaskOnly) {
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = `${sRadius}px sans-serif`;
            const fixedCol = document.getElementById('fixedColorPicker').value;
            for (let y = -sSpacing; y < canvas.height + sSpacing; y += sSpacing) {
                for (let x = -sSpacing; x < canvas.width + sSpacing; x += sSpacing) {
                    ctx.save();
                    const jitter = sSpacing * 0.35;
                    ctx.translate(x + (Math.random()-0.5)*jitter, y + (Math.random()-0.5)*jitter);
                    ctx.rotate(Math.random() * Math.PI * 2);
                    if (isMaskOnly) ctx.fillStyle = 'black';
                    else {
                        if (mode === 'random') ctx.fillStyle = `rgb(${Math.random()*255},${Math.random()*255},${Math.random()*255})`;
                        else if (mode === 'fixed') ctx.fillStyle = fixedCol;
                        else ctx.fillStyle = 'black';
                    }
                    ctx.fillText(shapes[Math.floor(Math.random()*shapes.length)], 0, 0);
                    ctx.restore();
                }
            }
        }

        function draw() {
            if (!img.src) return;
            const sRadius = parseInt(document.getElementById('radius').value);
            const sSpacing = parseInt(document.getElementById('spacing').value);
            const pX = parseInt(document.getElementById('posX').value) / 100;
            const pY = parseInt(document.getElementById('posY').value) / 100;
            const txt = document.getElementById('overlayText').value;
            let mode = 'hole', displayPos = 'board';
            document.getElementsByName('mode').forEach(r => { if(r.checked) mode = r.value; });
            document.getElementsByName('displayPos').forEach(r => { if(r.checked) displayPos = r.value; });

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (displayPos === 'board') {
                ctx.globalCompositeOperation = 'source-over'; ctx.drawImage(img, 0, 0);
                if (mode === 'hole') { ctx.globalCompositeOperation = 'destination-out'; drawSymbols(sRadius, sSpacing, mode, true); }
                else { ctx.globalCompositeOperation = 'source-over'; drawSymbols(sRadius, sSpacing, mode, false); }
            } else {
                ctx.globalCompositeOperation = 'source-over'; drawSymbols(sRadius, sSpacing, 'fixed', true);
                ctx.globalCompositeOperation = 'source-in'; ctx.drawImage(img, 0, 0);
            }
            ctx.globalCompositeOperation = 'source-over';
            if (txt) { ctx.font = `bold ${canvas.width/10}px sans-serif`; ctx.fillStyle = "#ffffff"; ctx.textAlign = 'center'; ctx.fillText(txt, canvas.width * pX, canvas.height * pY); }
        }

        document.getElementById('re-random').onclick = () => { if(img.src) draw(); };

        // ---æ ¸å¿ƒï¼šè½‰ç¢¼ MP4 é‚è¼¯ ---
        document.getElementById('record-mp4').onclick = async () => {
            if (!img.src) return alert('è«‹å…ˆä¸Šå‚³åœ–ç‰‡');
            isRecording = true;
            status.textContent = "â³ æ­£åœ¨åˆå§‹åŒ– MP4 å¼•æ“...";
            saveVideoBtn.style.display = 'none';

            if (!ffmpeg.isLoaded()) await ffmpeg.load();

            const targetSec = parseInt(document.getElementById('duration').value);
            const chunks = [];
            const stream = canvas.captureStream(30);
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });

            recorder.ondataavailable = (e) => chunks.push(e.data);
            recorder.onstop = async () => {
                status.textContent = "âš™ï¸ æ­£åœ¨è½‰ç¢¼ç‚º MP4 (æ­¤æ­¥é©Ÿè¼ƒæ…¢)...";
                const webmBlob = new Blob(chunks, { type: 'video/webm' });
                const webmName = 'input.webm';
                
                ffmpeg.FS('writeFile', webmName, await fetchFile(webmBlob));
                // åŸ·è¡Œè½‰ç¢¼ï¼šè½‰ç‚º H.264 MP4
                await ffmpeg.run('-i', webmName, '-c:v', 'libx264', '-pix_fmt', 'yuv420p', 'output.mp4');
                
                const data = ffmpeg.FS('readFile', 'output.mp4');
                const mp4Blob = new Blob([data.buffer], { type: 'video/mp4' });
                mp4Url = URL.createObjectURL(mp4Blob);
                
                videoPreview.src = mp4Url;
                videoContainer.style.display = 'block';
                saveVideoBtn.style.display = 'inline-block';
                isRecording = false;
                status.textContent = "âœ… MP4 ç”Ÿæˆå®Œç•¢ï¼";
            };

            recorder.start();
            const startTime = performance.now();
            const renderLoop = (time) => {
                if (!isRecording) return;
                const elapsed = time - startTime;
                if (elapsed < (targetSec * 1000 + 500)) {
                    draw();
                    status.textContent = `â³ éŒ„è£½åŸå§‹å½±æ ¼: ${Math.min(100, Math.round((elapsed/(targetSec*1000))*100))}%`;
                    requestAnimationFrame(renderLoop);
                } else { recorder.stop(); }
            };
            requestAnimationFrame(renderLoop);
        };

        saveVideoBtn.onclick = () => {
            const a = document.createElement('a');
            a.href = mp4Url;
            a.download = `protected_${Date.now()}.mp4`;
            a.click();
        };
    </script>
</body>
</html>
